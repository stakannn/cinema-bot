# Кинобот решает три запроса пользователей: 
## 1. Узнать сюжет фильма
Узнать сюжет фильма позволяет `state Plot`. Он срабатывает на запросы, содержашие слово "сюжет" и <название фильма>, а также на вопросы типа *"О чем <название фильма>"*, *"Про что <название фильма>"*. В ответ на запрос выдает описание сюжета и спрашивает пользователя, хочет ли он посмотреть этот фильм. Если да, переходит в `state HowManyTickets` , а оттуда уже к проверке и покупке. Если же пользователь отвечает, что сюжет ему не понравился, бот предлагает изучить сюжеты других фильмов, доступных в прокате.
Чтобы избежать путаницы при запросах вроде *"хочу купить билет на кавказскую пленницу, о чем она?"*, в которых бот может в прочитать намерение “купить”, а не “узнать сюжет”, паттернам в `state Plot` добавлен двойной вес.
## 2. Узнать стоимость билета
Стоимость билета узнается с помощью `state Price`. Этот state реагирует на запросы вида *"Сколько стоит билет на <название фильма>"*, *"Какая цена билета на <название фильма>"*. Если в запросе указано количество билетов, это учитывается. Например, после запроса *"Сколько стоит два билета на Кавказскую пленницу"* в сессионных переменных сохранится не только название фильма, но и желаемое количество билетов. А в ответе будет указана не только стоимость одного билета, но и общая стоимость указанного пользователем количества билетов. Далее пользователю предлагается указать, устраивает ли его цена. Если да, то, при необходимости, спрашивается необходимое количество билетов (если его изначально не было в запросе), а потом - проверка и покупка.
## 3. Купить билет
*Под "покупкой" билета подразумевается отправка сообщения с псевдоссылкой на оплату нужного количества билетов на нужный фильм*
### Варианты запросов для покупки билета можно разделить на три категории:
#### 1. Пользователь сразу указывает, на что хочет пойти и количество билетов
Например: *"Мне нужно купить два билета на кавказскую пленницу"* или *"хочу сто билетов на джентельменов"*\
В таком случае срабатывает паттерн в `state InstantPurchase`, а за ним проверка и покупка.
#### 2. Пользователь указывает, на что он хочет пойти, но не указывает количество билетов
Например: *"Хочу купить билет на пленницу"* или *"Хочу сходить на фильм джентельмены удачи"*\
При таком запросе реагирует `state HowManyTickets`, который считывает называние желаемого фильма и уточняет кол-во билетов, после чего проверка и покупка. Если на вопрос о желаемом кол-ве билетов пользователь пишет что-то, что точно не цифра (в том или ином виде), бот переспрашивает.
#### 3. Пользователь просто заявляет о желании купить билеты в кино
Например: *"Как купить билет"*\
Тогда срабатывает `state SuggestMovie`, в котором пользователю предлагается выбрать фильм из предложенных. Если пользователь пишет что-то, что бот не вопринимает как называние фильма, предлагается переформулировать. В целом, вероятность такого исхода снижается за счёт возможности выбрать фильм нажатием на кнопку с его названием. Однако в файле patterns.js можно увидеть, что бот в целом воспринимает довольно вольные изменения названий. Выбор пользователя записывается в сессионную переменную. Пользователь попадает в `state HowManyTickets`, который уточняет кол-во билетов, после чего проверка и покупка.
## Как происходит так называемая "проверка"?
В `state: Check` можно попасть только после `state HowManyTickets` или `state InstantPurchase`. К этому моменту в сессионных переменных уже есть вся необходимая информация: название фильма, количество билетов. Бот выводит сообщение со всей этой информацией и спрашивает у пользователя, верна ли она. Если да, отправляет псевдоссылку на оплату. Если нет, то сессионные переменные обнуляются и предлагается попробовать еще раз. 
## Какие ещё есть state_ы?
Помимо всего вышеописанного есть `state Start`, который срабатывает при первом запуске бота, `state Hello`, который реагирует на приветсвия, `state BotDescription`, который выдает описание "способностей" бота, `state StopPurchase`, который позволяет в любой момент прерывать сессию и начать заново, а также `state Bye`, который прощается с пользователем. И, разумеется, `state CatchAll`, который отлавливает всё, что бот не может понять и обработать.
